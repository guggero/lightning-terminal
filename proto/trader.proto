syntax = "proto3";

import "google/api/annotations.proto";
import "auctioneer.proto";

package poolrpc;

option go_package = "github.com/lightninglabs/pool/poolrpc";

service Trader {
    /*
    QuoteAccount gets a fee quote to fund an account of the given size with the
    given confirmation target. If the connected lnd wallet doesn't have enough
    balance to fund an account of the requested size, an error is returned.
    */
    rpc QuoteAccount (QuoteAccountRequest) returns (QuoteAccountResponse) {
        option (google.api.http) = {
            post: "/v1/pool/accounts/quote"
            body: "*"
        };
    };

    /* pool: `accounts new`
    InitAccount creates a new account with the requested size and expiration,
    funding it from the wallet of the connected lnd node.
    */
    rpc InitAccount (InitAccountRequest) returns (Account) {
        option (google.api.http) = {
            post: "/v1/pool/accounts"
            body: "*"
        };
    };

    /* pool: `accounts list`
    ListAccounts returns a list of all accounts known to the trader daemon and
    their current state.
    */
    rpc ListAccounts (ListAccountsRequest) returns (ListAccountsResponse) {
        option (google.api.http) = {
            get: "/v1/pool/accounts"
        };
    };

    /* pool: `accounts close`
    CloseAccount closes an account and returns the funds locked in that account
    to the connected lnd node's wallet.
    */
    rpc CloseAccount (CloseAccountRequest) returns (CloseAccountResponse) {
        option (google.api.http) = {
            delete: "/v1/pool/accounts"
        };
    };

    /* pool: `accounts withdraw`
    WithdrawAccount splits off parts of the account balance into the specified
    outputs while recreating the account with a reduced balance.
    */
    rpc WithdrawAccount (WithdrawAccountRequest) returns (WithdrawAccountResponse) {
        option (google.api.http) = {
            post: "/v1/pool/accounts/withdraw"
            body: "*"
        };
    };

    /* pool: `accounts deposit`
    DepositAccount adds more funds from the connected lnd node's wallet to an
    account.
    */
    rpc DepositAccount (DepositAccountRequest) returns (DepositAccountResponse) {
        option (google.api.http) = {
            post: "/v1/pool/accounts/deposit"
            body: "*"
        };
    };

    /* pool: `accounts bumpfee`
    BumpAccountFee attempts to bump the fee of an account's transaction through
    child-pays-for-parent (CPFP). Since the CPFP is performed through the
    backing lnd node, the account transaction must contain an output under its
    control for a successful bump. If a CPFP has already been performed for an
    account, and this RPC is invoked again, then a replacing transaction (RBF)
    of the child will be broadcast.
    */
    rpc BumpAccountFee (BumpAccountFeeRequest) returns (BumpAccountFeeResponse) {
        option (google.api.http) = {
            post: "/v1/pool/accounts/bump"
            body: "*"
        };
    };

    /* pool: `accounts recover`
    RecoverAccounts queries the auction server for this trader daemon's accounts
    in case we lost our local account database.
    */
    rpc RecoverAccounts (RecoverAccountsRequest) returns (RecoverAccountsResponse) {
        option (google.api.http) = {
            post: "/v1/pool/accounts/recover"
            body: "*"
        };
    };

    /* pool: `orders submit`
    SubmitOrder creates a new ask or bid order and submits for the given account
    and submits it to the auction server for matching.
    */
    rpc SubmitOrder (SubmitOrderRequest) returns (SubmitOrderResponse) {
        option (google.api.http) = {
            post: "/v1/pool/orders"
            body: "*"
        };
    };

    /* pool: `orders list`
    ListOrders returns a list of all active and archived orders that are
    currently known to the trader daemon.
    */
    rpc ListOrders (ListOrdersRequest) returns (ListOrdersResponse) {
        option (google.api.http) = {
            get: "/v1/pool/orders"
        };
    }

    /* pool: `orders cancel`
    CancelOrder cancels an active order with the auction server to remove it
    from future matching.
    */
    rpc CancelOrder (CancelOrderRequest) returns (CancelOrderResponse) {
        option (google.api.http) = {
            delete: "/v1/pool/orders/{order_nonce}"
        };
    };

    /* pool: `auction fee`
    AuctionFee returns the current auction order execution fee specified by the
    auction server.
    */
    rpc AuctionFee (AuctionFeeRequest) returns (AuctionFeeResponse) {
        option (google.api.http) = {
            get: "/v1/pool/fee"
        };
    };

    /* pool: `auction snapshot`
    BatchSnapshot returns the snapshot of a past batch identified by its ID.
    */
    rpc BatchSnapshot (BatchSnapshotRequest) returns (BatchSnapshotResponse) {
        option (google.api.http) = {
            get: "/v1/pool/batch/snapshot"
        };
    };

    /** pool: `listauth`
    GetLsatTokens returns all LSAT tokens the daemon ever paid for.
    */
    rpc GetLsatTokens (TokensRequest) returns (TokensResponse) {
        option (google.api.http) = {
            get: "/v1/lsat/tokens"
        };
    }
}

message InitAccountRequest {
    uint64 account_value = 1;

    oneof account_expiry {
        uint32 absolute_height = 2;
        uint32 relative_height = 3;
    }

    oneof fees {
        /*
        The target number of blocks that the transaction should be confirmed in.
        */
        uint32 conf_target = 4;

        // TODO(guggero): Add sat_per_vbyte as soon as lnd has a parameter for
        // that in rpcServer.EstimateFee.
    }
}

message QuoteAccountRequest {
    uint64 account_value = 1;

    oneof fees {
        /*
        The target number of blocks that the transaction should be confirmed in.
        */
        uint32 conf_target = 2;

        // TODO(guggero): Add sat_per_vbyte as soon as lnd has a parameter for
        // that in rpcServer.EstimateFee.
    }
}

message QuoteAccountResponse {
    uint64 miner_fee_rate_sat_per_kw = 1;

    uint64 miner_fee_total = 2;
}

message ListAccountsRequest {
}
message ListAccountsResponse {
    repeated Account accounts = 1;
}

message Output {
    // The value, in satoshis, of the output.
    uint64 value_sat = 1;

    // The address corresponding to the output.
    string address = 2;
}

message OutputWithFee {
    // The address corresponding to the output.
    string address = 1;

    oneof fees {
        /*
        The target number of blocks that the transaction should be confirmed in.
        */
        uint32 conf_target = 2;

        /*
        The fee rate, in satoshis per kw, to use for the withdrawal transaction.
        */
        uint64 fee_rate_sat_per_kw = 3;
    }
}

message OutputsWithImplicitFee {
    repeated Output outputs = 1;
}

message CloseAccountRequest {
    // The trader key associated with the account that will be closed.
    bytes trader_key = 1;

    oneof funds_destination {
        /*
        A single output/address to which the remaining funds of the account will
        be sent to at the specified fee. If an address is not specified, then
        the funds are sent to an address the backing lnd node controls.
        */
        OutputWithFee output_with_fee = 2;

        /*
        The outputs to which the remaining funds of the account will be sent to.
        This should only be used when wanting to create two or more outputs,
        otherwise OutputWithFee should be used instead. The fee of the account's
        closing transaction is implicitly defined by the combined value of all
        outputs.
        */
        OutputsWithImplicitFee outputs = 3;
    }
}
message CloseAccountResponse {
    // The hash of the closing transaction.
    bytes close_txid = 1;
}

message WithdrawAccountRequest {
    /*
    The trader key associated with the account that funds will be withdrawed
    from.
    */
    bytes trader_key = 1;

    // The outputs we'll withdraw funds from the account into.
    repeated Output outputs = 2;

    /*
    The fee rate, in satoshis per kw, to use for the withdrawal transaction.
    */
    uint64 fee_rate_sat_per_kw = 3;
}
message WithdrawAccountResponse {
    // The state of the account after processing the withdrawal.
    Account account = 1;

    // The transaction used to withdraw funds from the account.
    bytes withdraw_txid = 2;
}

message DepositAccountRequest {
    /*
    The trader key associated with the account that funds will be deposited
    into.
    */
    bytes trader_key = 1;

    // The amount in satoshis to deposit into the account.
    uint64 amount_sat = 2;

    /*
    The fee rate, in satoshis per kw, to use for the deposit transaction.
    */
    uint64 fee_rate_sat_per_kw = 3;
}
message DepositAccountResponse {
    // The state of the account after processing the deposit.
    Account account = 1;

    // The transaction used to deposit funds into the account.
    bytes deposit_txid = 2;
}

message BumpAccountFeeRequest {
    /*
    The trader key associated with the account that will have its fee bumped.
    */
    bytes trader_key = 1;

    /*
    The new fee rate, in satoshis per kw, to use for the child of the account
    transaction.
    */
    uint64 fee_rate_sat_per_kw = 2;
}
message BumpAccountFeeResponse {
}

enum AccountState {
    // The state of an account when it is pending its confirmation on-chain.
    PENDING_OPEN = 0;

    /*
    The state of an account when it has undergone an update on-chain either as
    part of a matched order or a trader modification and it is pending its
    confirmation on-chain.
    */
    PENDING_UPDATE = 1;

    // The state of an account once it has confirmed on-chain.
    OPEN = 2;

    /*
    The state of an account once its expiration has been reached and its closing
    transaction has confirmed.
    */
    EXPIRED = 3;

    /*
    The state of an account when we're waiting for the closing transaction of
    an account to confirm that required cooperation with the auctioneer.
    */
    PENDING_CLOSED = 4;

    // The state of an account once its closing transaction has confirmed.
    CLOSED = 5;

    /*
    The state of an account that indicates that the account was attempted to be
    recovered but failed because the opening transaction wasn't found by lnd.
    This could be because it was never published or it never confirmed. Then the
    funds are SAFU and the account can be considered to never have been opened
    in the first place.
    */
    RECOVERY_FAILED = 6;

    /*
    The account has recently participated in a batch and is not yet confirmed.
    */
    PENDING_BATCH = 7;
}

message Account {
    /*
    The identifying component of an account. This is the key used for the trader
    in the 2-of-2 multi-sig construction of an account with an auctioneer.
    */
    bytes trader_key = 1;

    /*
    The current outpoint associated with the account. This will change every
    time the account has been updated.
    */
    OutPoint outpoint = 2;

    // The current total amount of satoshis in the account.
    uint64 value = 3;

    /*
    The amount of satoshis in the account that is available, meaning not
    allocated to any oustanding orders.
    */
    uint64 available_balance = 4;

    // The height at which the account will expire.
    uint32 expiration_height = 5;

    // The current state of the account.
    AccountState state = 6;

    // The hash of the account's latest transaction.
    bytes latest_txid = 7;
}

message SubmitOrderRequest {
    oneof details {
        Ask ask = 1;
        Bid bid = 2;
    }
}
message SubmitOrderResponse {
    oneof details {
        /*
        Order failed with the given reason.
        */
        InvalidOrder invalid_order = 1;

        /*
        The order nonce of the accepted order.
        */
        bytes accepted_order_nonce = 2;
    }
}

message ListOrdersRequest {
}
message ListOrdersResponse {
    repeated Ask asks = 1;
    repeated Bid bids = 2;
}

message CancelOrderRequest {
    bytes order_nonce = 1;
}
message CancelOrderResponse {
}

message Order {
    /*
    The trader's account key of the account that is used for the order.
    */
    bytes trader_key = 1;

    /*
    Fixed order rate in parts per billion.
    */
    uint32 rate_fixed = 2;

    /*
    Order amount in satoshis.
    */
    uint64 amt = 3;

    /*
    Maximum fee rate the trader is willing to pay for the batch transaction,
    expressed in satoshis per 1000 weight units (sat/KW).
    */
    uint64 max_batch_fee_rate_sat_per_kw= 4;

    /*
    Order nonce, acts as unique order identifier.
    */
    bytes order_nonce = 5;

    /*
    The state the order currently is in.
    */
    OrderState state = 6;

    /*
    The number of order units the amount corresponds to.
    */
    uint32 units = 7;

    /*
    The number of currently unfilled units of this order. This will be equal to
    the total amount of units until the order has reached the state PARTIAL_FILL
    or EXECUTED.
    */
    uint32 units_unfulfilled = 8;

    // The value reserved from the account by this order to ensure the account
    // can pay execution and chain fees in case it gets matched.
    uint64 reserved_value_sat = 9;
}

message Bid {
    /*
    The common fields shared between both ask and bid order types.
    */
    Order details = 1;

    /*
    Required minimum number of blocks that a channel opened as a result of this
    bid should be kept open.
    */
    uint32 min_duration_blocks = 2;

    /*
    The version of the order format that is used. Will be increased once new
    features are added.
    */
    uint32 version = 3;
}

message Ask {
    /*
    The common fields shared between both ask and bid order types.
    */
    Order details = 1;

    /*
    The maximum number of blocks the liquidity provider is willing to provide
    the channel funds for.
    */
    uint32 max_duration_blocks = 2;

    /*
    The version of the order format that is used. Will be increased once new
    features are added.
    */
    uint32 version = 3;
}

message RecoverAccountsRequest {
}

message RecoverAccountsResponse {
    // The number of accounts that were recovered.
    uint32 num_recovered_accounts = 1;
}

message AuctionFeeRequest {
}

message AuctionFeeResponse {
    /*
    The execution fee charged per matched order.
    */
    ExecutionFee execution_fee = 1;
}

message TokensRequest {
}

message TokensResponse {
    /**
    List of all tokens the daemon knows of, including old/expired tokens.
    */
    repeated LsatToken tokens = 1;
}

message LsatToken {
    /**
    The base macaroon that was baked by the auth server.
    */
    bytes base_macaroon = 1;

    /**
    The payment hash of the payment that was paid to obtain the token.
    */
    bytes payment_hash = 2;

    /**
    The preimage of the payment hash, knowledge of this is proof that the
    payment has been paid. If the preimage is set to all zeros, this means the
    payment is still pending and the token is not yet fully valid.
    */
    bytes payment_preimage = 3;

    /**
    The amount of millisatoshis that was paid to get the token.
    */
    int64 amount_paid_msat = 4;

    /**
    The amount of millisatoshis paid in routing fee to pay for the token.
    */
    int64 routing_fee_paid_msat = 5;

    /**
    The creation time of the token as UNIX timestamp in seconds.
    */
    int64 time_created = 6;

    /**
    Indicates whether the token is expired or still valid.
    */
    bool expired = 7;

    /**
    Identifying attribute of this token in the store. Currently represents the
    file name of the token where it's stored on the file system.
    */
    string storage_name = 8;
}
